
HumidityMeasurement.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000028a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000236  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  0000028a  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000002bc  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000030  00000000  00000000  000002fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000927  00000000  00000000  0000032c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000747  00000000  00000000  00000c53  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003a6  00000000  00000000  0000139a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000058  00000000  00000000  00001740  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003e7  00000000  00000000  00001798  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000118  00000000  00000000  00001b7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000058  00000000  00000000  00001c97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 54 00 	call	0xa8	; 0xa8 <main>
  78:	0c 94 19 01 	jmp	0x232	; 0x232 <_exit>

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <USART_init>:
#include <stdlib.h>

#define PIN 6

void USART_init() {
  UBRR0H = 0;
  80:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
  UBRR0L = 0b001100111;
  84:	87 e6       	ldi	r24, 0x67	; 103
  86:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
  UCSR0B = (1<<RXEN0) | (1<<TXEN0);
  8a:	88 e1       	ldi	r24, 0x18	; 24
  8c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  UCSR0C = (1<<USBS0) | (3<<UCSZ00);
  90:	8e e0       	ldi	r24, 0x0E	; 14
  92:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
  96:	08 95       	ret

00000098 <USART_send>:
}

void USART_send(unsigned int data){
  while(!(UCSR0A & (1<<UDRE0)));
  98:	e0 ec       	ldi	r30, 0xC0	; 192
  9a:	f0 e0       	ldi	r31, 0x00	; 0
  9c:	90 81       	ld	r25, Z
  9e:	95 ff       	sbrs	r25, 5
  a0:	fd cf       	rjmp	.-6      	; 0x9c <USART_send+0x4>
  UDR0 = data;
  a2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  a6:	08 95       	ret

000000a8 <main>:
}

int main(void)
{
  a8:	cf 93       	push	r28
  aa:	df 93       	push	r29
  ac:	cd b7       	in	r28, 0x3d	; 61
  ae:	de b7       	in	r29, 0x3e	; 62
  b0:	c7 54       	subi	r28, 0x47	; 71
  b2:	d1 40       	sbci	r29, 0x01	; 1
  b4:	0f b6       	in	r0, 0x3f	; 63
  b6:	f8 94       	cli
  b8:	de bf       	out	0x3e, r29	; 62
  ba:	0f be       	out	0x3f, r0	; 63
  bc:	cd bf       	out	0x3d, r28	; 61
  uint8_t data[5];
  USART_init();
  be:	0e 94 40 00 	call	0x80	; 0x80 <USART_init>
  DDRD &= ~(1<<PIN);
  c2:	56 98       	cbi	0x0a, 6	; 10
  PORTD |= (1<<PIN);
  c4:	5e 9a       	sbi	0x0b, 6	; 11
  c6:	7e 01       	movw	r14, r28
  c8:	26 e0       	ldi	r18, 0x06	; 6
  ca:	e2 0e       	add	r14, r18
  cc:	f1 1c       	adc	r15, r1
  ce:	8e 01       	movw	r16, r28
  d0:	0a 5b       	subi	r16, 0xBA	; 186
  d2:	1e 4f       	sbci	r17, 0xFE	; 254
    PORTD |= (1<<PIN);
    _delay_us(40);

    //WAIT FOR 80us LOW SIGNAL AND THEN HIGH SIGNAL
    while((PIND & (1 << PIN)) == 0x00);
    while((PIND & (1 << PIN)) == (1 << PIN));
  d4:	ca 5b       	subi	r28, 0xBA	; 186
  d6:	de 4f       	sbci	r29, 0xFE	; 254
  d8:	e8 82       	st	Y, r14
  da:	c6 54       	subi	r28, 0x46	; 70
  dc:	d1 40       	sbci	r29, 0x01	; 1
  de:	c9 5b       	subi	r28, 0xB9	; 185
  e0:	de 4f       	sbci	r29, 0xFE	; 254
  e2:	f8 82       	st	Y, r15
  e4:	c7 54       	subi	r28, 0x47	; 71
  e6:	d1 40       	sbci	r29, 0x01	; 1
    for( int i = 0; i < 80; i+=2 ){
       uint32_t lowCycles  = cycles[2*i];
       uint32_t highCycles = cycles[2*i+1];
       uint32_t  count1, count2;
         count1 = count2 = 0;
       while((PIND & (1 << PIN)) == 0x00){
  e8:	a1 2c       	mov	r10, r1
  ea:	b1 2c       	mov	r11, r1
  ec:	c1 2c       	mov	r12, r1
  ee:	d1 2c       	mov	r13, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f0:	8f ef       	ldi	r24, 0xFF	; 255
  f2:	97 ea       	ldi	r25, 0xA7	; 167
  f4:	21 e6       	ldi	r18, 0x61	; 97
  f6:	81 50       	subi	r24, 0x01	; 1
  f8:	90 40       	sbci	r25, 0x00	; 0
  fa:	20 40       	sbci	r18, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <main+0x4e>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <main+0x58>
 100:	00 00       	nop
  DDRD &= ~(1<<PIN);
  PORTD |= (1<<PIN);
    while (1) 
    {
    _delay_ms(2000);
    data[0] = data[1] = data[2] = data[3] = data[4] = 0;
 102:	1d 82       	std	Y+5, r1	; 0x05
 104:	1c 82       	std	Y+4, r1	; 0x04
 106:	1b 82       	std	Y+3, r1	; 0x03
 108:	1a 82       	std	Y+2, r1	; 0x02
 10a:	19 82       	std	Y+1, r1	; 0x01
    
    //INPUT PULL UP
    DDRD &= ~(1<<PIN);
 10c:	56 98       	cbi	0x0a, 6	; 10
    PORTD |= (1<<PIN);
 10e:	5e 9a       	sbi	0x0b, 6	; 11
 110:	8f e9       	ldi	r24, 0x9F	; 159
 112:	9f e0       	ldi	r25, 0x0F	; 15
 114:	01 97       	sbiw	r24, 0x01	; 1
 116:	f1 f7       	brne	.-4      	; 0x114 <main+0x6c>
 118:	00 c0       	rjmp	.+0      	; 0x11a <main+0x72>
 11a:	00 00       	nop
    _delay_ms(1);
    
    //SET LINE AS LOW
    DDRD |= (1<<PIN);
 11c:	56 9a       	sbi	0x0a, 6	; 10
    PORTD &= ~(1<<PIN);
 11e:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 120:	8f e2       	ldi	r24, 0x2F	; 47
 122:	91 e1       	ldi	r25, 0x11	; 17
 124:	01 97       	sbiw	r24, 0x01	; 1
 126:	f1 f7       	brne	.-4      	; 0x124 <main+0x7c>
 128:	00 c0       	rjmp	.+0      	; 0x12a <main+0x82>
 12a:	00 00       	nop
    _delay_us(1100);
    
    uint32_t cycles[80];
    
    //CRITICAL AREA
    cli();
 12c:	f8 94       	cli
    DDRD &= ~(1<<PIN);
 12e:	56 98       	cbi	0x0a, 6	; 10
    PORTD |= (1<<PIN);
 130:	5e 9a       	sbi	0x0b, 6	; 11
 132:	95 ed       	ldi	r25, 0xD5	; 213
 134:	9a 95       	dec	r25
 136:	f1 f7       	brne	.-4      	; 0x134 <main+0x8c>
 138:	00 00       	nop
    _delay_us(40);

    //WAIT FOR 80us LOW SIGNAL AND THEN HIGH SIGNAL
    while((PIND & (1 << PIN)) == 0x00);
 13a:	4e 9b       	sbis	0x09, 6	; 9
 13c:	fe cf       	rjmp	.-4      	; 0x13a <main+0x92>
    while((PIND & (1 << PIN)) == (1 << PIN));
 13e:	4e 99       	sbic	0x09, 6	; 9
 140:	fe cf       	rjmp	.-4      	; 0x13e <main+0x96>
 142:	a7 01       	movw	r20, r14
 144:	ca 5b       	subi	r28, 0xBA	; 186
 146:	de 4f       	sbci	r29, 0xFE	; 254
 148:	e8 81       	ld	r30, Y
 14a:	c6 54       	subi	r28, 0x46	; 70
 14c:	d1 40       	sbci	r29, 0x01	; 1
 14e:	c9 5b       	subi	r28, 0xB9	; 185
 150:	de 4f       	sbci	r29, 0xFE	; 254
 152:	f8 81       	ld	r31, Y
 154:	c7 54       	subi	r28, 0x47	; 71
 156:	d1 40       	sbci	r29, 0x01	; 1
 158:	27 c0       	rjmp	.+78     	; 0x1a8 <main+0x100>
    for( int i = 0; i < 80; i+=2 ){
       uint32_t lowCycles  = cycles[2*i];
       uint32_t highCycles = cycles[2*i+1];
       uint32_t  count1, count2;
         count1 = count2 = 0;
       while((PIND & (1 << PIN)) == 0x00){
 15a:	8a 2d       	mov	r24, r10
 15c:	9b 2d       	mov	r25, r11
 15e:	ac 2d       	mov	r26, r12
 160:	bd 2d       	mov	r27, r13
         count1++;  
 162:	01 96       	adiw	r24, 0x01	; 1
 164:	a1 1d       	adc	r26, r1
 166:	b1 1d       	adc	r27, r1
    for( int i = 0; i < 80; i+=2 ){
       uint32_t lowCycles  = cycles[2*i];
       uint32_t highCycles = cycles[2*i+1];
       uint32_t  count1, count2;
         count1 = count2 = 0;
       while((PIND & (1 << PIN)) == 0x00){
 168:	4e 9b       	sbis	0x09, 6	; 9
 16a:	fb cf       	rjmp	.-10     	; 0x162 <main+0xba>
         count1++;  
       }
       while((PIND & (1 << PIN)) != 0x00){
 16c:	4e 9b       	sbis	0x09, 6	; 9
 16e:	0c c0       	rjmp	.+24     	; 0x188 <main+0xe0>
 170:	4a 2c       	mov	r4, r10
 172:	5b 2c       	mov	r5, r11
 174:	6c 2c       	mov	r6, r12
 176:	7d 2c       	mov	r7, r13
         count2++;
 178:	2f ef       	ldi	r18, 0xFF	; 255
 17a:	42 1a       	sub	r4, r18
 17c:	52 0a       	sbc	r5, r18
 17e:	62 0a       	sbc	r6, r18
 180:	72 0a       	sbc	r7, r18
       uint32_t  count1, count2;
         count1 = count2 = 0;
       while((PIND & (1 << PIN)) == 0x00){
         count1++;  
       }
       while((PIND & (1 << PIN)) != 0x00){
 182:	4e 99       	sbic	0x09, 6	; 9
 184:	f9 cf       	rjmp	.-14     	; 0x178 <main+0xd0>
 186:	04 c0       	rjmp	.+8      	; 0x190 <main+0xe8>
 188:	4a 2c       	mov	r4, r10
 18a:	5b 2c       	mov	r5, r11
 18c:	6c 2c       	mov	r6, r12
 18e:	7d 2c       	mov	r7, r13
         count2++;
       }
       cycles[i] = count1;
 190:	80 83       	st	Z, r24
 192:	91 83       	std	Z+1, r25	; 0x01
 194:	a2 83       	std	Z+2, r26	; 0x02
 196:	b3 83       	std	Z+3, r27	; 0x03
       cycles[i+1] = count2;
 198:	44 82       	std	Z+4, r4	; 0x04
 19a:	55 82       	std	Z+5, r5	; 0x05
 19c:	66 82       	std	Z+6, r6	; 0x06
 19e:	77 82       	std	Z+7, r7	; 0x07
 1a0:	38 96       	adiw	r30, 0x08	; 8

    //WAIT FOR 80us LOW SIGNAL AND THEN HIGH SIGNAL
    while((PIND & (1 << PIN)) == 0x00);
    while((PIND & (1 << PIN)) == (1 << PIN));
    
    for( int i = 0; i < 80; i+=2 ){
 1a2:	e0 17       	cp	r30, r16
 1a4:	f1 07       	cpc	r31, r17
 1a6:	39 f0       	breq	.+14     	; 0x1b6 <main+0x10e>
       uint32_t lowCycles  = cycles[2*i];
       uint32_t highCycles = cycles[2*i+1];
       uint32_t  count1, count2;
         count1 = count2 = 0;
       while((PIND & (1 << PIN)) == 0x00){
 1a8:	4e 9b       	sbis	0x09, 6	; 9
 1aa:	d7 cf       	rjmp	.-82     	; 0x15a <main+0xb2>
 1ac:	8a 2d       	mov	r24, r10
 1ae:	9b 2d       	mov	r25, r11
 1b0:	ac 2d       	mov	r26, r12
 1b2:	bd 2d       	mov	r27, r13
 1b4:	db cf       	rjmp	.-74     	; 0x16c <main+0xc4>
       cycles[i] = count1;
       cycles[i+1] = count2;
    }
    
    //END OF CRITICAL AREA
    sei();
 1b6:	78 94       	sei
    
    //CONVERT PULSE LENGTH TO VALUE
    for (int i=0; i<40; ++i) {
 1b8:	20 e0       	ldi	r18, 0x00	; 0
 1ba:	30 e0       	ldi	r19, 0x00	; 0
 1bc:	fa 01       	movw	r30, r20
      uint32_t lowCycles  = cycles[2*i];
      uint32_t highCycles = cycles[2*i+1];
      data[i/8] <<= 1;
 1be:	c9 01       	movw	r24, r18
 1c0:	33 23       	and	r19, r19
 1c2:	0c f4       	brge	.+2      	; 0x1c6 <main+0x11e>
 1c4:	07 96       	adiw	r24, 0x07	; 7
 1c6:	95 95       	asr	r25
 1c8:	87 95       	ror	r24
 1ca:	95 95       	asr	r25
 1cc:	87 95       	ror	r24
 1ce:	95 95       	asr	r25
 1d0:	87 95       	ror	r24
 1d2:	a1 e0       	ldi	r26, 0x01	; 1
 1d4:	b0 e0       	ldi	r27, 0x00	; 0
 1d6:	ac 0f       	add	r26, r28
 1d8:	bd 1f       	adc	r27, r29
 1da:	a8 0f       	add	r26, r24
 1dc:	b9 1f       	adc	r27, r25
 1de:	6c 91       	ld	r22, X
 1e0:	66 0f       	add	r22, r22
      if (highCycles > lowCycles) {
 1e2:	20 80       	ld	r2, Z
 1e4:	31 80       	ldd	r3, Z+1	; 0x01
 1e6:	42 80       	ldd	r4, Z+2	; 0x02
 1e8:	53 80       	ldd	r5, Z+3	; 0x03
 1ea:	64 80       	ldd	r6, Z+4	; 0x04
 1ec:	75 80       	ldd	r7, Z+5	; 0x05
 1ee:	86 80       	ldd	r8, Z+6	; 0x06
 1f0:	97 80       	ldd	r9, Z+7	; 0x07
 1f2:	26 14       	cp	r2, r6
 1f4:	37 04       	cpc	r3, r7
 1f6:	48 04       	cpc	r4, r8
 1f8:	59 04       	cpc	r5, r9
 1fa:	18 f0       	brcs	.+6      	; 0x202 <main+0x15a>
    
    //CONVERT PULSE LENGTH TO VALUE
    for (int i=0; i<40; ++i) {
      uint32_t lowCycles  = cycles[2*i];
      uint32_t highCycles = cycles[2*i+1];
      data[i/8] <<= 1;
 1fc:	fd 01       	movw	r30, r26
 1fe:	60 83       	st	Z, r22
 200:	08 c0       	rjmp	.+16     	; 0x212 <main+0x16a>
      if (highCycles > lowCycles) {
        data[i/8] |= 1;
 202:	e1 e0       	ldi	r30, 0x01	; 1
 204:	f0 e0       	ldi	r31, 0x00	; 0
 206:	ec 0f       	add	r30, r28
 208:	fd 1f       	adc	r31, r29
 20a:	e8 0f       	add	r30, r24
 20c:	f9 1f       	adc	r31, r25
 20e:	61 60       	ori	r22, 0x01	; 1
 210:	60 83       	st	Z, r22
    
    //END OF CRITICAL AREA
    sei();
    
    //CONVERT PULSE LENGTH TO VALUE
    for (int i=0; i<40; ++i) {
 212:	2f 5f       	subi	r18, 0xFF	; 255
 214:	3f 4f       	sbci	r19, 0xFF	; 255
 216:	48 5f       	subi	r20, 0xF8	; 248
 218:	5f 4f       	sbci	r21, 0xFF	; 255
 21a:	28 32       	cpi	r18, 0x28	; 40
 21c:	31 05       	cpc	r19, r1
 21e:	71 f6       	brne	.-100    	; 0x1bc <main+0x114>
      if (highCycles > lowCycles) {
        data[i/8] |= 1;
      }
    }
    
	USART_send(data[0]);
 220:	89 81       	ldd	r24, Y+1	; 0x01
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	0e 94 4c 00 	call	0x98	; 0x98 <USART_send>
	USART_send(data[1]);
 228:	8a 81       	ldd	r24, Y+2	; 0x02
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	0e 94 4c 00 	call	0x98	; 0x98 <USART_send>
    str = String(f, 6);
    str.toCharArray(h, 7);
    for(int i = 0; i < strlen(h); i++)
      USART_send(h[i]);
    USART_send('\n');*/
    }
 230:	5f cf       	rjmp	.-322    	; 0xf0 <main+0x48>

00000232 <_exit>:
 232:	f8 94       	cli

00000234 <__stop_program>:
 234:	ff cf       	rjmp	.-2      	; 0x234 <__stop_program>
